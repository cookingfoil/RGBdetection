import numpy as np
import cv2
import matplotlib.pyplot as plt
import time
import pygame

cap = cv2.VideoCapture("C:/Users/IMLAB/Desktop/bigdot2.mp4")

# Check if camera opened successfully
if cap.isOpened() == False:
    print("Error opening video stream or file")

length = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
img = np.zeros([1,3], dtype=np.uint8)
#print(img)

frame_number = 0
stop_frame = length-100
fig = plt.figure()


# Read until video is completed
while (cap.isOpened()):

############# RGB detection
    # frame_number = frame_number + 1
    # time.sleep(0.5)
    # # Capture frame-by-frame
    # ret, frame = cap.read()
    # # print(frame.shape)
    # framergb = frame[:,:,:]
    # # lower_yellow = np.array([120,180,210])
    # # upper_yellow = np.array([160, 215, 255])
    #
    # # yellow boxes
    # # lower_yellow = np.array([100, 160, 190])
    # # upper_yellow = np.array([180, 230, 255])
    #
    # # green boxes
    # lower_yellow = np.array([149, 130, 130])
    # upper_yellow = np.array([170, 170, 160])
    #
    # mask = cv2.inRange(framergb, lower_yellow, upper_yellow)
    # res = cv2.bitwise_and(frame, frame, mask = mask)
    #
    # cv2.imshow('frame', frame)
    # # cv2.imshow('mask', mask)
    # cv2.imshow('res', res)
    # k = cv2.waitKey(5) & 0xFF
    # if k == 27:
    #     break
############# RGB detection

############# HSV detection
    frame_number = frame_number + 1
    time.sleep(0.1)
    # Capture frame-by-frame
    ret, frame = cap.read()
    # print(frame.shape)

    framebgr = frame[:, :, :]
    # bgr = [140, 200, 220]
    bgr = [160, 150, 155]
    # bgr = [0, 128, 0]

    thresh = 20

    minBGR = np.array([bgr[0] - thresh, bgr[1] - thresh, bgr[2] - thresh])
    maxBGR = np.array([bgr[0] + thresh, bgr[1] + thresh, bgr[2] + thresh])

    maskBGR = cv2.inRange(framebgr,minBGR,maxBGR)
    resultBGR = cv2.bitwise_and(framebgr, framebgr, mask = maskBGR)

    # convert to HSV
    brightHSV = cv2.cvtColor(framebgr, cv2.COLOR_BGR2HSV)
    hsv = cv2.cvtColor(np.uint8([[bgr]]), cv2.COLOR_BGR2HSV)[0][0]

    minHSV = np.array([hsv[0] - thresh, hsv[1] - thresh, hsv[2] - thresh])
    maxHSV = np.array([hsv[0] + thresh, hsv[1] + thresh, hsv[2] + thresh])

    maskHSV = cv2.inRange(brightHSV, minHSV, maxHSV)
    resultHSV = cv2.bitwise_and(brightHSV, brightHSV, mask=maskHSV)

    cv2.imshow('Result HSV', resultHSV)
    # # cv2.imshow('mask', mask)
    # cv2.imshow('res', res)
    k = cv2.waitKey(5) & 0xFF
    if k == 27:
        break
############# HSV detection


    if ret == True:
        if frame_number < stop_frame:
            # for i in range(1080):
            #     for j in range(1920):
            #         # print(frame[i,j])
            #          if (120 < frame[i,j,0] < 160) and (180 < frame[i,j,1] < 215) and (210 < frame[i,j,2] < 255):
            #             cv2.imshow('rgbdetection', frame)
            #             cv2.circle(frame, (i, j), 10, (0, 255, 255), thickness=10)
            print(frame_number)
            pixel = frame[:,:]
            cv2.imshow('Frame', frame)

            average = pixel.mean(axis=0).mean(axis=0)
            print (average)
            img = img + average
            # img = cv2.imread('frame', cv2.IMREAD_COLOR)[200,200,[2,1,0]]
            # print(img)

            continue

        elif frame_number >= stop_frame:
            # Display the resulting frame
            overallavg = img / length
            print(overallavg)
            cv2.imshow('Frame', frame)
            # image_filtering(frame)

            # Press Q on keyboard to  exit
            if cv2.waitKey(25) & 0xFF == ord('q'):
                print(frame_number)
                image_filtering(frame)

    # Break the loop
    else:
        break

# When everything done, release the video capture object
cap.release()

##########################################################################
# import numpy as np
# import cv2
#
# # the size of the image that fills the Color window
# COLOR_ROWS = 80
# COLOR_COLS = 250
#
# capture = cv2.VideoCapture("C:/Users/IMLAB/Desktop/video1.mp4")
# if not capture.isOpened():
#     raise RuntimeError('Error opening VideoCapture.')
#
# (grabbed, frame) = capture.read()
# snapshot = np.zeros(frame.shape, dtype=np.uint8)
# cv2.imshow('Snapshot', snapshot)
#
# colorArray = np.zeros((COLOR_ROWS, COLOR_COLS, 3), dtype=np.uint8)
# cv2.imshow('Color', colorArray)
#
#
# def on_mouse_click(event, x, y, flags, userParams):
#     if event == cv2.EVENT_LBUTTONDOWN:
#         colorArray[:] = snapshot[y, x, :]
#         rgb = snapshot[y, x, [2, 1, 0]]
#
#         # From stackoverflow.com/questions/1855884/determine-font-color-based-on-background-color
#         luminance = 1 - (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) / 255
#         if luminance < 0.5:
#             textColor = [0, 0, 0]
#         else:
#             textColor = [255, 255, 255]
#
#         cv2.putText(colorArray, str(rgb), (20, COLOR_ROWS - 20),
#                     fontFace=cv2.FONT_HERSHEY_SIMPLEX, fontScale=0.8, color=textColor)
#         cv2.imshow('Color', colorArray)
#
# cv2.setMouseCallback('Snapshot', on_mouse_click)
#
# while True:
#     (grabbed, frame) = capture.read()
#     cv2.imshow('Video', frame)
#
#     if not grabbed:
#         break
#
#     keyVal = cv2.waitKey(1) & 0xFF
#     if keyVal == ord('q'):
#         break
#     elif keyVal == ord('t'):
#         snapshot = frame.copy()
#         cv2.imshow('Snapshot', snapshot)
#
# capture.release()
# cv2.destroyAllWindows()
